<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>The pdnsd FAQ</title>
    <style type="text/css">
      <!--
      #small { font-family:helvetica; font-size:small; text-align:center; }
      // -->
    </style>
  </head>

  <body bgcolor="#EEEEEE">
    <!--notext(-->
    <table width="100%">
      <tr>
	<td> <span id="small">
	    <a href="index.html">pdnsd Homepage</a>
	  </span></td> 
	<td> <span id="small">
	    <a href="faq.html">pdnsd FAQ</a>
	  </span></td>
	<td> <span id="small">
	    <a href="doc.html">Documentation</a>
	  </span></td>
	<td> <span id="small">
	    <a href="COPYING">GNU GPL (pdnsd's License)</a>
	  </span> </td>
	<td><span id="small">
	    <a href="dl.html">Download Section</a>
	  </span></td>
      </tr>
    </table> 
    <!--)notext-->
    <h1>The pdnsd FAQ</h1>
    <a name="q001"></a>
    <table width="100%" cellspacing=1 cellpadding=7>
      <tr>
	<td bgcolor="#FFCCFF"><b>Q:</b></td>
	<td bgcolor="#CCFFFF">
	  There are complete and well-tested name servers around, such as the BIND. 
	  These do also perform caching. Why should I use pdnsd?
	</td>
      </tr>
      <tr>
	<td bgcolor="#FFCCFF"><b>A:</b></td>
	<td bgcolor="#CCFFFF">
	  pdnsd does not aim to be a complete name server implementation, such as the
	  BIND. It is optimized for caching, and you can only specify a small subset of all
	  dns record types pdnsd knows in your local &quot;zone&quot; definitions. 
	  This of course reduces the code size drastically, and such the memory footprint.
	  There are some features especially interesting for dialin networks, ordinary
	  (non-server) internet hosts and computers that are often not connected to
	  to their network, e.g. notebooks (I originally wrote this program for use
	  with my notebook).
	  These features are:
	  <ul>
	    <li> permanent disk cache (useful for frequent power-offs/reboots)
	    <li> usually smaller memory footprint (depends on cache size) (see next question)
	    <li> offline-detection prevents hangs (e.g. the typical hang on startup of some 
	      Netscape Navigator versions if not dialled in)
	    <li> better control about timeouts (also to prevent hangs)
	    <li> better control over the cache
	    <li> better run-time control
	  </ul>
	</td>
      </tr>
    </table>
    <hr>
    <a name="q002"></a>
    <table width="100%" cellspacing=1 cellpadding=7>
      <tr>
	<td bgcolor="#FFCCFF"><b>Q:</b></td>
	<td bgcolor="#CCFFFF">
	  When I look at the process size with ps, top, gtop, or a similar tool, I see
	  some processes with a total size well above 3.5 MB. This is much more than 
	  e.g. BIND named (about 1.4 MB). Why?
	</td>
      </tr>
      <tr>
	<td bgcolor="#FFCCFF"><b>A:</b></td>
	<td bgcolor="#CCFFFF">
	  Really, it is not.
	  pdnsd uses multithreading, not multiprocessing. That means that the processes 
	  share most of their process space. In the LinuxThreads library
	  (which is used by pdnsd on Linux), in fact the total process address space is shared
	  (although the processes have different stacks, these are in one process
	  address space). You may check this by looking at the at the process sizes of 
	  the  pdnsd threads: all should be the same. The effective size that pdnsd 
	  occupies is thus the size of any of the processes, not the sum of those.
	  So, pdnsd with empty cache occupies about 800 kB, and the maximum size
	  should be about the cache size plus this size (in fact, ca 5-10% more).
	</td>
      </tr>
    </table>
    <hr>
    <a name="q003"></a>
    <table width="100%" cellspacing=1 cellpadding=7>
      <tr>
	<td bgcolor="#FFCCFF"><b>Q:</b></td>
	<td bgcolor="#CCFFFF">
	  What do I need the status control (option -s) for?
	</td>
      </tr>
      <tr>
	<td bgcolor="#FFCCFF"><b>A:</b></td>
	<td bgcolor="#CCFFFF">
	  It enables you to do some things you might or might not need. With it, you can:
	  <ul>
	    <li> query pdnsd's settings at runtime to debug configuration files and
	      see which servers are regarded to be available
	    <li> mark servers as available or unavailable, or force a status retest - very
	      handy if you want to control which servers pdnsd queries, e.g for muliple
	      dial-up accounts
	    <li> delete, invalidate or add DNS records - useful e.g. when you want to build
	      records for dynamically assigned IP addresses or domain names.
	  </ul>
	</td>
      </tr>
    </table>
    <hr>
    <a name="q004"></a>
    <table width="100%" cellspacing=1 cellpadding=7>
      <tr>
	<td bgcolor="#FFCCFF"><b>Q:</b></td>
	<td bgcolor="#CCFFFF">
	  What do I need local records (rr- and source-sections in the config file) for?
	</td>
      </tr>
      <tr>
	<td bgcolor="#FFCCFF"><b>A:</b></td>
	<td bgcolor="#CCFFFF">
	  Some resolver programs, e.g. nslookup, want to look up the name of the 
	  server they are using before doing anything else. This option is for defining
	  a PTR record for your IP such that those programs get an answer even if the
	  name server you are caching is not available or does not offer these records.
	  By extension, you may also define A and SOA records. This allows you to build
	  very small zones without having to use a &quot;big&quot; name server. It is NOT 
	  intended to replace such a complete server in anything but VERY small 
	  networks. Alternatively, you may start a named on another host or on the 
	  same host on another port and cache it with pdnsd in addition to other (more
	  distant) name servers.
	  <br>
	  The <code>source</code> source section allows you to let pdnsd read in your 
	  <code>/etc/hosts</code> file on startup and serve its contents. This file is used by your local 
	  resolver before it even  tries the name servers and usually contains 
	  fully-qualified domain names (FQDNs) for all of the internet addresses your host has. 
	  If you source this file, you usually won't need any additional <code>rr</code> sections. Sourcing it also allows
	  other hosts (eg. in your local network) to access the names defined in your
	  hosts file. You can of course just add other hosts in your local network to the
	  servers <code>hosts</code> file, thus making them known to your server's resolver
	  and pdnsd (if you sourced that file).
	  <br>
	  If you don't know what this answer was all about, you should just take the
	  source section in the sample config file that comes with pdnsd, copy it
	  into your config file and forget about it.
	</td>
      </tr>
    </table>
    <hr>
    <a name="q005"></a>
    <table width="100%" cellspacing=1 cellpadding=7>
      <tr>
	<td bgcolor="#FFCCFF"><b>Q:</b></td>
	<td bgcolor="#CCFFFF">
	  When compiling, I get an error message like <br><i>Please define __BYTE_ORDER to
	  be __LITTLE_ENDIAN or __BIG_ENDIAN</i><br> What's up?
	</td>
      </tr>
      <tr>
	<td bgcolor="#FFCCFF"><b>A:</b></td>
	<td bgcolor="#CCFFFF">
	  Normally, this macros should be defined in your C library's header files.
	  There are two different methods, most C libraries support both (and pdnsd
	  honors both): either <code>__BYTE_ORDER</code> is set to <code>__LITTLE_ENDIAN</code>
	  or <code>__BIG_ENDIAN</code>, or <code>__LITTLE_ENDIAN</code> or <code>__BIG_ENDIAN</code>
	  are directly defined as macros.
	  <br>
	  Linux glibc, for example, does set those macros correctly. Never mind. You just have to know
	  whether your machine is little-endian or big-endian, this means wheter your
	  machine saves the least significant byte of a word or double-word first in memory (little-endian) or
	  the most significant first (big-endian). 
	  All intel x86 and Alpha machines are little-endian, for example, while SPARC
	  and PowerPC architectures are big-endian.
	  If your machine is little-endian, add the following line to your config.h:
	  <br><code>
	    #define __BYTE_ORDER __LITTLE_ENDIAN
	  </code><br>
	  Likewise, if your machines byte order is big-endian:
	  <br><code>
	    #define __BYTE_ORDER __BIG_ENDIAN
	  </code><br>
	  Pathological byte orders like pdp-endian are not yet supported really;
	  However, for the place the endianess is needed, <code>__LITTLE_ENDIAN</code> should do
	  (it deals only with 16 bits; for all other occurances, ntoh[sl]/hton[sl] is used).
	</td>
      </tr>
    </table>
    <hr>
    <a name="q007"></a>
    <table width="100%" cellspacing=1 cellpadding=7>
      <tr>
	<td bgcolor="#FFCCFF"><b>Q:</b></td>
	<td bgcolor="#CCFFFF">
	  At startup, I get a warning saying:<br> 
	  <i>
	    Uptest command [...] will implicitely be executed as root 
	  </i> <br>
	  What does that mean?
	</td>
      </tr>
      <tr>
	<td bgcolor="#FFCCFF"><b>A:</b></td>
	<td bgcolor="#CCFFFF">
	  This warning only occurs if you use the <code>uptest=exec</code> option in your 
	  configuration. It means that the uptest command is run as root
	  because pdnsd is running as root, and this was not explicitely specified.
	  The idea is that it may introduce security holes (in the programs being run) 
	  when they run as root, and so they shouldn't do that if possible.
	  You can specify the user that shall run the command by appending its name
	  comma-separated as string to the <code>uptest_cmd</code> line: <br>
	  <code>
	    uptest_cmd=&quot;&lt;your command&gt;&quot;,&quot;&lt;user&gt;&quot;;
	  </code> <br>
	  If it is correctly running as root, just append the user string <code>&quot;root&quot;</code> to
	  the command and the warning will not occur again.
	</td>
      </tr>
    </table>
    <hr>
    <a name="q008"></a>
    <table width="100%" cellspacing=1 cellpadding=7>
      <tr>
	<td bgcolor="#FFCCFF"><b>Q:</b></td>
	<td bgcolor="#CCFFFF">
	  I cannot run my <code>uptest_cmd</code> command as root (it says <i>permission denied</i>), 
	  although the pdnsd executable is setuid root. Why?
	</td>
      </tr>
      <tr>
	<td bgcolor="#FFCCFF"><b>A:</b></td>
	<td bgcolor="#CCFFFF">
	  pdnsd will drop privileges gained through setuid/setgid before executing the
	  uptest commands (you shouldn't set the pdnsd executable setuid/setgid anyway). 
	  The reason is clear: if you install the pdnsd
	  executable as setuid root and this wouln't be done, any user could execute
	  shellcode with root privileges using that option!
	</td>
      </tr>
    </table>
    <hr>
    <a name="q009"></a>
    <table width="100%" cellspacing=1 cellpadding=7>
      <tr>
	<td bgcolor="#FFCCFF"><b>Q:</b></td>
	<td bgcolor="#CCFFFF">
	  At startup, I get an error saying:<br>
	  <i>
	    Bad config file permissions: the file must be only writeable by the user
	  </i><br>
	  Why that?
	</td>
      </tr>
      <tr>
	<td bgcolor="#FFCCFF"><b>A:</b></td>
	<td bgcolor="#CCFFFF">
	  pdnsd has an option (<code>uptest=exec</code>) that allows the execution of arbitrary 
	  shell code (for testing whether an interface is up). This must be
	  of course secured against unauthorized use. One of these
	  protection is the one that produces the error message: if you routinely run
	  pdnsd, e.g. at system startup, and your config file is editable for others,
	  someone could change it and insert shell code that is executed in the next
	  pdnsd run -- with your user privileges! To prevent this, pdnsd will exit if the config file is writeable
	  by others than the owner.
	  To get rid of this message, just do <br>
	  <code>
	    chmod go-w &lt;filename&gt;
	  </code><br>
	  on your config
	  file (for the default file: <code>chmod go-w /etc/pdnsd.conf</code>).
	  You should also check that the ownership is set correct.
	</td>
      </tr>
    </table>
    <hr>
    <a name="q010"></a>
    <table width="100%" cellspacing=1 cellpadding=7>
      <tr>
	<td bgcolor="#FFCCFF"><b>Q:</b></td>
	<td bgcolor="#CCFFFF">
	  <code>serve_aliases</code> does not seem to work.
	</td>
      </tr>
      <tr>
	<td bgcolor="#FFCCFF"><b>A:</b></td>
	<td bgcolor="#CCFFFF">
	  Some resolvers (e.g. of the glibc 2.1) seem sometimes not to look up unmodified names, but the names with
	  an entry of the search path already appended. Since pdnsd will serve short names with this 
	  option anyway, you can delete the search an domain options from your /etc/resolv.conf. This is reported to
	  work in some cases.
	</td>
      </tr>
    </table>
    <hr>
    <table width="100%" cellspacing=1 cellpadding=7>
     <tr>
        <td bgcolor="#FFCCFF"><b>Q:</b></td>
	<td bgcolor="#CCFFFF">
	  Some queries for domains that have many records (e.g. www.gmx.de) fail mysteriously.
	</td>
      </tr>
      <tr>
	<td bgcolor="#FFCCFF"><b>A:</b></td>
	<td bgcolor="#CCFFFF">
	  pdnsd versions prior to 1.1.0 had the tcp server thread disabled by default. Most resolvers
	  repeat their query using tcp when they receive a truncated answer (the answer is truncated
	  when it exceeds a length of 512 bytes). You need to recompile pdnsd with the option
	  <code>--enable-tcp-server</code> to fix this.
	</td>
      </tr>
    </table>
<!--<hr>
    <a name="q011"></a>
    <table width="100%" cellspacing=1 cellpadding=7>
     <tr>
        <td bgcolor="#FFCCFF"><b>Q:</b></td>
	<td bgcolor="#CCFFFF">
	</td>
      </tr>
      <tr>
	<td bgcolor="#FFCCFF"><b>A:</b></td>
	<td bgcolor="#CCFFFF">
	</td>
      </tr>
    </table>-->
    <hr>
    <address><a href="mailto:tmoestl@gmx.net">Thomas Moestl</a></address>
    <br>
    <p>
      $Id: faq.html,v 1.9 2003/04/06 23:19:14 tmm Exp $
    </p>
  </body>
</html>

